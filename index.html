<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Force Directed ER diagram</title>
    <style>
      * {
        position: absolute;
      }

      div {
        position: absolute;
        top: 0;
        left: 0;
        height: 1px;
        width: 100px;
        background: #000;
      }

      code {
        background-color: black;
        color: wheat;
        padding: 3px;
        white-space: pre;
        font-size: 11px;
      }

      textarea {
        width: 70vw;
        height: 70vh;
      }
    </style>
  </head>

  <body>
    <header style="width: 100vw; height: 100vh;"></header>
    <button>DRAW</button><label style="left: 100px;"><input type="checkbox" id="oracle" value="oracle" style="left: -20px;"> oracle</label>
    <textarea placeholder="input DDL" style="top: 30px"></textarea>
    <main style="width: 100vw; height: 100vh; display: none"></main>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/mysqldump-ddl-parser@0.0.3/dist/mysqldump-ddl-parser.min.js"></script>
    <script src="https://unpkg.com/pluralize@8.0.0/pluralize.js"></script>
    <script>
      const button = document.querySelector("button");
      const textarea = document.querySelector("textarea");
      const main = document.querySelector("main");
      const body = document.querySelector("body");
      const zoom = {
        zoom: 1,
        x: 0,
        y: 0,
        prev: {
          x: null,
          y: null
        }
      };
      function setZoom() {
        main.style.transform = `translate(${zoom.x}px, ${zoom.y}px) scale(${zoom.zoom})`;
      }
      body.addEventListener('wheel', function(event){
        zoom.zoom = zoom.zoom * (1 - (event.deltaY / Math.abs(event.deltaY) / 10));
        setZoom();
      });
      function resetMoveState(event){
        zoom.prev.x = event.x;
        zoom.prev.y = event.y;
      }
      function move(event){
        if(zoom.prev.x) {
          zoom.x = zoom.x + event.x - zoom.prev.x;
          zoom.y = zoom.y + event.y - zoom.prev.y;
          resetMoveState(event);
          setZoom();
        }
      }
      function finishMove(event){
        zoom.prev.x = null;
        zoom.prev.y = null;
      }
      body.addEventListener('mousedown', resetMoveState);
      body.addEventListener('mousemove', move);
      body.addEventListener('mouseup', finishMove);
      button.addEventListener("click", function () {
        let tables;
        if(document.querySelector('#oracle').value) {
          MysqldumpDdlParser(textarea.value, 'oracle');
        } else {
          MysqldumpDdlParser(textarea.value);
        }
        tables = setIndex(tables);
        textarea.style.display = button.style.display = "none";
        main.style.display = "block";
        const relations = [];
        Object.keys(tables).forEach((key) => {
          const table = tables[key];
          table.foreignKeys.forEach((fkey) => {
            if (tables[fkey.referenceTable]) {
              relations.push([table.index, tables[fkey.referenceTable].index]);
            }
          });
          table.columns.forEach((column) => {
            if (!column.name.endsWith("_id")) return;
            const name = column.name.replace(/_id/, "");
            const pluralizedName = pluralize(name);
            let target = tables[pluralizedName] || tables[name];
            if (target) {
              relations.push([table.index, target.index]);
            }
          });
        });
        const nodes = [];
        Object.keys(tables).forEach((key) => {
          nodes[tables[key].index] = tables[key];
        });
        draw(
          nodes,
          relations.map((link) => ({
            source: link[0],
            target: link[1],
          }))
        );
      });

      function setIndex(obj) {
        const result = Object.assign({}, obj);
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          result[keys[i]].index = i;
          result[keys[i]].open = false;
          result[keys[i]].focus = false;
        }
        return obj;
      }

      function calcLine(a, b) {
        const source = Object.assign({}, a.x < b.x ? a : b);
        const target = Object.assign({}, a.x < b.x ? b : a);
        const sourceText = source.label.split(/\n/);
        const targetText = target.label.split(/\n/);
        source.x += Math.max(sourceText.map(t => tx.length)) * 3;
        source.y += sourceText.length * 5;
        target.x += Math.max(targetText.map(t => tx.length)) * 3;
        target.y += targetText.length * 5;
        const w = target.x - source.x;
        const h = target.y - source.y;

        const result = {
          x: source.x,
          y: source.y,
          length: Math.sqrt(w * w + h * h),
          deg: (Math.atan2(h, w) * 360) / (2 * Math.PI),
        };
        return result;
      }

      const colors = [
        "#9F1B34",
        "#A21E1B",
        "#A53B1B",
        "#A84E0E",
        "#AA6600",
        "#A77B00",
        "#A48F00",
        "#918E00",
        "#717D00",
        "#147600",
        "#006F3E",
        "#00694E",
        "#00625C",
        "#005E69",
        "#00526F",
        "#004972",
        "#004075",
        "#1A3374",
        "#343472",
        "#482D69",
        "#5A265F",
        "#70245F",
        "#811F4C",
        "#901E43",
      ];
      const darkColors = [
        "#642A2E",
        "#6A2E28",
        "#6F3826",
        "#704020",
        "#704B1A",
        "#6E551B",
        "#6B5E1B",
        "#615C19",
        "#535617",
        "#235418",
        "#185138",
        "#0B4B3C",
        "#004542",
        "#00464C",
        "#004252",
        "#0A3A50",
        "#14344E",
        "#212B4E",
        "#312E4D",
        "#3A2C49",
        "#422944",
        "#512C46",
        "#5D2D3F",
        "#612C37",
      ];
      function draw(nodes, links) {
        const link = d3
          .select("main")
          .selectAll("div")
          .data(links)
          .enter()
          .append("div")
          .style("background-color", function (d) {
            return colors[d.target % colors.length];
          });

        const node = d3
          .select("main")
          .selectAll("code")
          .data(nodes)
          .enter()
          .append("code")
          .style("background-color", function (d) {
            return darkColors[d.index % darkColors.length];
          })
          .text(function (d) {
            d.label = d.open ? d.sql : d.name;
            return d.label;
          })
          .call(
            d3
              .drag()
              .on("start", function (d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                d.open = true;
                d.focus = true;
                node.text(function (d) {
                  d.label = d.open ? d.sql : d.name;
                  return d.label;
                });
              })
              .on("drag", function (d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
              })
              // .on("end", function (d) {
              //   d.fx = null;
              //   d.fy = null;
              // })
          );

        const simulation = d3.forceSimulation();
        simulation
          .velocityDecay(0.2)
          .force("link", d3.forceLink())
          .force(
            "collide",
            d3
              .forceCollide()
              .radius(function (d) {
                return 270;
              })
              .strength(0.3)
              .iterations(30)
          )
          .force("charge", d3.forceManyBody().strength(-50000))
          .force("center", d3.forceCenter(2000, 2000))
          .force("collision", d3.forceCollide(200))  
          .force("x", d3.forceX().x(1000).strength(0.7)).force("y", d3.forceY().y(1000).strength(0.7));

        simulation.nodes(nodes);

        simulation
          .force("link")
          .links(links)
          .distance(function (d) {
            return 100;
          });

        simulation.on("tick", function () {
          link
            .style("left", function (d) {
              const line = calcLine(d.source, d.target);
              return line.x - line.length / 2 + "px";
            })
            .style("top", function (d) {
              const line = calcLine(d.source, d.target);
              return line.y + "px";
            })
            .style("width", function (d) {
              const line = calcLine(d.source, d.target);
              return `${line.length}px`;
            })
            .style("transform", function (d) {
              const line = calcLine(d.source, d.target);
              return `rotateZ(${line.deg}deg) translate(${line.length / 2}px)`;
            });
          node
            .style("left", function (d) {
              return `${d.x}px`;
            })
            .style("top", function (d) {
              return `${d.y}px`;
            })
        });
      }
    </script>
  </body>
</html>
